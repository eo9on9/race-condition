# Race Condition

이전에 일할 때, 렌더링 타이밍과 관련된 **race condition** 이슈를 경험한 적이 있다.
구체적으로는 **렌더링이 완료되기 전에 상태가 다시 업데이트**되면서 발생하는 문제였고,
React에서는 **일반적으로 상태 업데이트에 대한 동시성 처리가 잘 되어 있기 때문에 흔히 보기 어려운 상황**이었다.

이슈는 앱이 직접적으로 오류를 일으키거나 동작에 치명적인 영향을 주지는 않아서 백로그로 남겨두었지만,, 이번에 궁금증을 해결해 보고싶었다.

당시에 외부 상태 저장소를 두고 있었고, 여러 컴포넌트에서 API를 호출하고, 그 API 함수 내에서 외부 상태 저장소의 값을 업데이트하는 구조였다.
이 과정에서 구독 중인 컴포넌트들의 렌더링이 끝나기도 전에 상태가 다시 변경되면서, 내부적으로 충돌이 발생한 것으로 보인다.

위 이슈를 재현해보기 위해,
useSyncExternalStore 기반의 외부 상태 저장소를 구성하고, 다양한 방식으로 연속적인 상태 업데이트를 유도했지만,
렌더 트리가 충분히 복잡하지 않아서인지, 혹은 렌더링 자체가 너무 빨리 끝나서인지 문제는 재현되지 않았다.

이 과정에서 관련 자료를 조사하던 중, React가 react-dom에서 제공하는 unstable_batchedUpdates() 함수를 알게 되었다.
이 함수는 React 외부에서 여러 번의 상태 업데이트가 발생할 때, 이를 하나의 렌더링 사이클로 묶어주는 역할을 한다.
React 내부 컨텍스트가 아닌 곳에서 상태가 자주 변경될 경우, 컴포넌트가 과도하게 렌더링되는 현상을 방지하기 위해 유용하다.

돌이켜보면, 당시 발생했던 이슈도 외부 상태 저장소에서 리스너를 실행하는 부분을
unstable_batchedUpdates로 감싸는 방식으로 해결할 수 있었을지도 모르겠다.

앞으로 렌더링 구조가 조금 더 복잡한 테스트 환경을 구성해보게 되면,
이 이슈의 재현을 다시 시도해보고, unstable_batchedUpdates를 통한 해결 가능성을 직접 검증해봐야겠다.
